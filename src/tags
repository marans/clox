!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALLOCATE	memory.h	/^#define ALLOCATE(/;"	d
ALLOCATE_OBJ	object.c	/^#define ALLOCATE_OBJ(/;"	d	file:
AS_BOOL	value.h	/^#define AS_BOOL(/;"	d
AS_CLASS	object.h	/^#define AS_CLASS(/;"	d
AS_CLOSURE	object.h	/^#define AS_CLOSURE(/;"	d
AS_CSTRING	object.h	/^#define AS_CSTRING(/;"	d
AS_FUNCTION	object.h	/^#define AS_FUNCTION(/;"	d
AS_NATIVE	object.h	/^#define AS_NATIVE(/;"	d
AS_NUMBER	value.h	/^#define AS_NUMBER(/;"	d
AS_OBJ	value.h	/^#define AS_OBJ(/;"	d
AS_STRING	object.h	/^#define AS_STRING(/;"	d
BINARY_OP	vm.c	/^#define BINARY_OP(/;"	d	file:
BINARY_OP	vm.c	/^#undef BINARY_OP$/;"	d	file:
BOOL_VAL	value.h	/^#define BOOL_VAL(/;"	d
CallFrame	vm.h	/^} CallFrame;$/;"	t	typeref:struct:__anon23
Chunk	chunk.h	/^} Chunk;$/;"	t	typeref:struct:__anon3
Compiler	compiler.c	/^typedef struct Compiler {$/;"	s	file:
Compiler	compiler.c	/^} Compiler;$/;"	t	typeref:struct:Compiler	file:
DEBUG_LOG_GC	common.h	/^#define DEBUG_LOG_GC$/;"	d
DEBUG_PRINT_CODE	common.h	/^#define DEBUG_PRINT_CODE$/;"	d
DEBUG_STRESS_GC	common.h	/^#define DEBUG_STRESS_GC$/;"	d
DEBUG_TRACE_EXECUTION	common.h	/^#define DEBUG_TRACE_EXECUTION$/;"	d
Entry	table.h	/^} Entry;$/;"	t	typeref:struct:__anon21
FRAMES_MAX	vm.h	/^#define FRAMES_MAX /;"	d
FREE	memory.h	/^#define FREE(/;"	d
FREE_ARRAY	memory.h	/^#define FREE_ARRAY(/;"	d
FunctionType	compiler.c	/^} FunctionType;$/;"	t	typeref:enum:__anon15	file:
GC_HEAP_GROW_FACTOR	memory.c	/^#define GC_HEAP_GROW_FACTOR /;"	d	file:
GROW_ARRAY	memory.h	/^#define GROW_ARRAY(/;"	d
GROW_CAPACITY	memory.h	/^#define GROW_CAPACITY(/;"	d
INTERPRET_COMPILE_ERROR	vm.h	/^  INTERPRET_COMPILE_ERROR,$/;"	e	enum:__anon25
INTERPRET_OK	vm.h	/^  INTERPRET_OK,$/;"	e	enum:__anon25
INTERPRET_RUNTIME_ERROR	vm.h	/^  INTERPRET_RUNTIME_ERROR$/;"	e	enum:__anon25
IS_BOOL	value.h	/^#define IS_BOOL(/;"	d
IS_CLASS	object.h	/^#define IS_CLASS(/;"	d
IS_CLOSURE	object.h	/^#define IS_CLOSURE(/;"	d
IS_FUNCTION	object.h	/^#define IS_FUNCTION(/;"	d
IS_NATIVE	object.h	/^#define IS_NATIVE(/;"	d
IS_NIL	value.h	/^#define IS_NIL(/;"	d
IS_NUMBER	value.h	/^#define IS_NUMBER(/;"	d
IS_OBJ	value.h	/^#define IS_OBJ(/;"	d
IS_STRING	object.h	/^#define IS_STRING(/;"	d
InterpretResult	vm.h	/^} InterpretResult;$/;"	t	typeref:enum:__anon25
Local	compiler.c	/^} Local;$/;"	t	typeref:struct:__anon13	file:
NIL_VAL	value.h	/^#define NIL_VAL /;"	d
NUMBER_VAL	value.h	/^#define NUMBER_VAL(/;"	d
NativeFn	object.h	/^typedef Value (*NativeFn)(int argCount, Value* args);$/;"	t
OBJ_CLASS	object.h	/^  OBJ_CLASS,$/;"	e	enum:__anon16
OBJ_CLOSURE	object.h	/^  OBJ_CLOSURE,$/;"	e	enum:__anon16
OBJ_FUNCTION	object.h	/^  OBJ_FUNCTION,$/;"	e	enum:__anon16
OBJ_NATIVE	object.h	/^  OBJ_NATIVE,$/;"	e	enum:__anon16
OBJ_STRING	object.h	/^  OBJ_STRING,$/;"	e	enum:__anon16
OBJ_TYPE	object.h	/^#define OBJ_TYPE(/;"	d
OBJ_UPVALUE	object.h	/^  OBJ_UPVALUE$/;"	e	enum:__anon16
OBJ_VAL	value.h	/^#define OBJ_VAL(/;"	d
OP_ADD	chunk.h	/^  OP_ADD,$/;"	e	enum:__anon2
OP_CALL	chunk.h	/^  OP_CALL,$/;"	e	enum:__anon2
OP_CLOSE_UPVALUE	chunk.h	/^  OP_CLOSE_UPVALUE,$/;"	e	enum:__anon2
OP_CLOSURE	chunk.h	/^  OP_CLOSURE,$/;"	e	enum:__anon2
OP_CONSTANT	chunk.h	/^  OP_CONSTANT,$/;"	e	enum:__anon2
OP_DEFINE_GLOBAL	chunk.h	/^  OP_DEFINE_GLOBAL,$/;"	e	enum:__anon2
OP_DIVIDE	chunk.h	/^  OP_DIVIDE,$/;"	e	enum:__anon2
OP_EQUAL	chunk.h	/^  OP_EQUAL,$/;"	e	enum:__anon2
OP_FALSE	chunk.h	/^  OP_FALSE,$/;"	e	enum:__anon2
OP_GET_GLOBAL	chunk.h	/^  OP_GET_GLOBAL,$/;"	e	enum:__anon2
OP_GET_LOCAL	chunk.h	/^  OP_GET_LOCAL,$/;"	e	enum:__anon2
OP_GET_UPVALUE	chunk.h	/^  OP_GET_UPVALUE,$/;"	e	enum:__anon2
OP_GREATER	chunk.h	/^  OP_GREATER,$/;"	e	enum:__anon2
OP_JUMP	chunk.h	/^  OP_JUMP,$/;"	e	enum:__anon2
OP_JUMP_IF_FALSE	chunk.h	/^  OP_JUMP_IF_FALSE,$/;"	e	enum:__anon2
OP_LESS	chunk.h	/^  OP_LESS,$/;"	e	enum:__anon2
OP_LOOP	chunk.h	/^  OP_LOOP,$/;"	e	enum:__anon2
OP_MULTIPLY	chunk.h	/^  OP_MULTIPLY,$/;"	e	enum:__anon2
OP_NEGATE	chunk.h	/^  OP_NEGATE,$/;"	e	enum:__anon2
OP_NIL	chunk.h	/^  OP_NIL,$/;"	e	enum:__anon2
OP_NOT	chunk.h	/^  OP_NOT,$/;"	e	enum:__anon2
OP_POP	chunk.h	/^  OP_POP,$/;"	e	enum:__anon2
OP_PRINT	chunk.h	/^  OP_PRINT,$/;"	e	enum:__anon2
OP_RETURN	chunk.h	/^  OP_RETURN,$/;"	e	enum:__anon2
OP_SET_GLOBAL	chunk.h	/^  OP_SET_GLOBAL,$/;"	e	enum:__anon2
OP_SET_LOCAL	chunk.h	/^  OP_SET_LOCAL,$/;"	e	enum:__anon2
OP_SET_UPVALUE	chunk.h	/^  OP_SET_UPVALUE,$/;"	e	enum:__anon2
OP_SUBTRACT	chunk.h	/^  OP_SUBTRACT,$/;"	e	enum:__anon2
OP_TRUE	chunk.h	/^  OP_TRUE,$/;"	e	enum:__anon2
Obj	value.h	/^typedef struct sObj Obj;$/;"	t	typeref:struct:sObj
ObjClass	object.h	/^} ObjClass;$/;"	t	typeref:struct:__anon20
ObjClosure	object.h	/^} ObjClosure;$/;"	t	typeref:struct:__anon19
ObjFunction	object.h	/^} ObjFunction;$/;"	t	typeref:struct:__anon17
ObjNative	object.h	/^} ObjNative;$/;"	t	typeref:struct:__anon18
ObjString	value.h	/^typedef struct sObjString ObjString;$/;"	t	typeref:struct:sObjString
ObjType	object.h	/^} ObjType;$/;"	t	typeref:enum:__anon16
ObjUpvalue	object.h	/^typedef struct ObjUpvalue {$/;"	s
ObjUpvalue	object.h	/^} ObjUpvalue;$/;"	t	typeref:struct:ObjUpvalue
OpCode	chunk.h	/^} OpCode;$/;"	t	typeref:enum:__anon2
PREC_AND	compiler.c	/^  PREC_AND,         \/\/ and$/;"	e	enum:__anon11	file:
PREC_ASSIGNMENT	compiler.c	/^  PREC_ASSIGNMENT,  \/\/ =$/;"	e	enum:__anon11	file:
PREC_CALL	compiler.c	/^  PREC_CALL,        \/\/ . ()$/;"	e	enum:__anon11	file:
PREC_COMPARISON	compiler.c	/^  PREC_COMPARISON,  \/\/ < > <= >=$/;"	e	enum:__anon11	file:
PREC_EQUALITY	compiler.c	/^  PREC_EQUALITY,    \/\/ == !=$/;"	e	enum:__anon11	file:
PREC_FACTOR	compiler.c	/^  PREC_FACTOR,      \/\/ * \/$/;"	e	enum:__anon11	file:
PREC_NONE	compiler.c	/^  PREC_NONE,$/;"	e	enum:__anon11	file:
PREC_OR	compiler.c	/^  PREC_OR,          \/\/ or$/;"	e	enum:__anon11	file:
PREC_PRIMARY	compiler.c	/^  PREC_PRIMARY$/;"	e	enum:__anon11	file:
PREC_TERM	compiler.c	/^  PREC_TERM,        \/\/ + -$/;"	e	enum:__anon11	file:
PREC_UNARY	compiler.c	/^  PREC_UNARY,       \/\/ ! -$/;"	e	enum:__anon11	file:
ParseFn	compiler.c	/^typedef void (*ParseFn)(bool canAssign);$/;"	t	file:
ParseRule	compiler.c	/^} ParseRule;$/;"	t	typeref:struct:__anon12	file:
Parser	compiler.c	/^} Parser;$/;"	t	typeref:struct:__anon10	file:
Precedence	compiler.c	/^} Precedence;$/;"	t	typeref:enum:__anon11	file:
READ_BYTE	vm.c	/^#define READ_BYTE(/;"	d	file:
READ_BYTE	vm.c	/^#undef READ_BYTE$/;"	d	file:
READ_CONSTANT	vm.c	/^#define READ_CONSTANT(/;"	d	file:
READ_CONSTANT	vm.c	/^#undef READ_CONSTANT$/;"	d	file:
READ_SHORT	vm.c	/^#define READ_SHORT(/;"	d	file:
READ_SHORT	vm.c	/^#undef READ_SHORT$/;"	d	file:
READ_STRING	vm.c	/^#define READ_STRING(/;"	d	file:
READ_STRING	vm.c	/^#undef READ_STRING$/;"	d	file:
STACK_MAX	vm.h	/^#define STACK_MAX /;"	d
Scanner	scanner.c	/^} Scanner;$/;"	t	typeref:struct:__anon1	file:
TABLE_MAX_LOAD	table.c	/^#define TABLE_MAX_LOAD /;"	d	file:
TOKEN_AND	scanner.h	/^  TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,$/;"	e	enum:__anon8
TOKEN_BANG	scanner.h	/^  TOKEN_BANG, TOKEN_BANG_EQUAL,$/;"	e	enum:__anon8
TOKEN_BANG_EQUAL	scanner.h	/^  TOKEN_BANG, TOKEN_BANG_EQUAL,$/;"	e	enum:__anon8
TOKEN_CLASS	scanner.h	/^  TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,$/;"	e	enum:__anon8
TOKEN_COMMA	scanner.h	/^  TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,$/;"	e	enum:__anon8
TOKEN_DOT	scanner.h	/^  TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,$/;"	e	enum:__anon8
TOKEN_ELSE	scanner.h	/^  TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,$/;"	e	enum:__anon8
TOKEN_EOF	scanner.h	/^  TOKEN_EOF$/;"	e	enum:__anon8
TOKEN_EQUAL	scanner.h	/^  TOKEN_EQUAL, TOKEN_EQUAL_EQUAL,$/;"	e	enum:__anon8
TOKEN_EQUAL_EQUAL	scanner.h	/^  TOKEN_EQUAL, TOKEN_EQUAL_EQUAL,$/;"	e	enum:__anon8
TOKEN_ERROR	scanner.h	/^  TOKEN_ERROR,$/;"	e	enum:__anon8
TOKEN_FALSE	scanner.h	/^  TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,$/;"	e	enum:__anon8
TOKEN_FOR	scanner.h	/^  TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,$/;"	e	enum:__anon8
TOKEN_FUN	scanner.h	/^  TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,$/;"	e	enum:__anon8
TOKEN_GREATER	scanner.h	/^  TOKEN_GREATER, TOKEN_GREATER_EQUAL,$/;"	e	enum:__anon8
TOKEN_GREATER_EQUAL	scanner.h	/^  TOKEN_GREATER, TOKEN_GREATER_EQUAL,$/;"	e	enum:__anon8
TOKEN_IDENTIFIER	scanner.h	/^  TOKEN_IDENTIFIER, TOKEN_STRING, TOKEN_NUMBER,$/;"	e	enum:__anon8
TOKEN_IF	scanner.h	/^  TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,$/;"	e	enum:__anon8
TOKEN_LEFT_BRACE	scanner.h	/^  TOKEN_LEFT_BRACE, TOKEN_RIGHT_BRACE,$/;"	e	enum:__anon8
TOKEN_LEFT_PAREN	scanner.h	/^  TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN,$/;"	e	enum:__anon8
TOKEN_LESS	scanner.h	/^  TOKEN_LESS, TOKEN_LESS_EQUAL,$/;"	e	enum:__anon8
TOKEN_LESS_EQUAL	scanner.h	/^  TOKEN_LESS, TOKEN_LESS_EQUAL,$/;"	e	enum:__anon8
TOKEN_MINUS	scanner.h	/^  TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,$/;"	e	enum:__anon8
TOKEN_NIL	scanner.h	/^  TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,$/;"	e	enum:__anon8
TOKEN_NUMBER	scanner.h	/^  TOKEN_IDENTIFIER, TOKEN_STRING, TOKEN_NUMBER,$/;"	e	enum:__anon8
TOKEN_OR	scanner.h	/^  TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,$/;"	e	enum:__anon8
TOKEN_PLUS	scanner.h	/^  TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,$/;"	e	enum:__anon8
TOKEN_PRINT	scanner.h	/^  TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,$/;"	e	enum:__anon8
TOKEN_RETURN	scanner.h	/^  TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,$/;"	e	enum:__anon8
TOKEN_RIGHT_BRACE	scanner.h	/^  TOKEN_LEFT_BRACE, TOKEN_RIGHT_BRACE,$/;"	e	enum:__anon8
TOKEN_RIGHT_PAREN	scanner.h	/^  TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN,$/;"	e	enum:__anon8
TOKEN_SEMICOLON	scanner.h	/^  TOKEN_SEMICOLON, TOKEN_SLASH, TOKEN_STAR,$/;"	e	enum:__anon8
TOKEN_SLASH	scanner.h	/^  TOKEN_SEMICOLON, TOKEN_SLASH, TOKEN_STAR,$/;"	e	enum:__anon8
TOKEN_STAR	scanner.h	/^  TOKEN_SEMICOLON, TOKEN_SLASH, TOKEN_STAR,$/;"	e	enum:__anon8
TOKEN_STRING	scanner.h	/^  TOKEN_IDENTIFIER, TOKEN_STRING, TOKEN_NUMBER,$/;"	e	enum:__anon8
TOKEN_SUPER	scanner.h	/^  TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,$/;"	e	enum:__anon8
TOKEN_THIS	scanner.h	/^  TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,$/;"	e	enum:__anon8
TOKEN_TRUE	scanner.h	/^  TOKEN_TRUE, TOKEN_VAR, TOKEN_WHILE,$/;"	e	enum:__anon8
TOKEN_VAR	scanner.h	/^  TOKEN_TRUE, TOKEN_VAR, TOKEN_WHILE,$/;"	e	enum:__anon8
TOKEN_WHILE	scanner.h	/^  TOKEN_TRUE, TOKEN_VAR, TOKEN_WHILE,$/;"	e	enum:__anon8
TYPE_FUNCTION	compiler.c	/^  TYPE_FUNCTION,$/;"	e	enum:__anon15	file:
TYPE_SCRIPT	compiler.c	/^  TYPE_SCRIPT$/;"	e	enum:__anon15	file:
Table	table.h	/^} Table;$/;"	t	typeref:struct:__anon22
Token	scanner.h	/^} Token;$/;"	t	typeref:struct:__anon9
TokenType	scanner.h	/^} TokenType;$/;"	t	typeref:enum:__anon8
UINT8_COUNT	common.h	/^#define UINT8_COUNT /;"	d
Upvalue	compiler.c	/^} Upvalue;$/;"	t	typeref:struct:__anon14	file:
VAL_BOOL	value.h	/^  VAL_BOOL,$/;"	e	enum:__anon4
VAL_NIL	value.h	/^  VAL_NIL, $/;"	e	enum:__anon4
VAL_NUMBER	value.h	/^  VAL_NUMBER,$/;"	e	enum:__anon4
VAL_OBJ	value.h	/^  VAL_OBJ$/;"	e	enum:__anon4
VM	vm.h	/^} VM;$/;"	t	typeref:struct:__anon24
Value	value.h	/^} Value;$/;"	t	typeref:struct:__anon5
ValueArray	value.h	/^} ValueArray;$/;"	t	typeref:struct:__anon7
ValueType	value.h	/^} ValueType;$/;"	t	typeref:enum:__anon4
addConstant	chunk.c	/^int addConstant(Chunk* chunk, Value value) {$/;"	f
addLocal	compiler.c	/^static void addLocal(Token name) {$/;"	f	file:
addUpvalue	compiler.c	/^static int addUpvalue(Compiler* compiler, uint8_t index,$/;"	f	file:
adjustCapacity	table.c	/^static void adjustCapacity(Table* table, int capacity) {$/;"	f	file:
advance	compiler.c	/^static void advance() {$/;"	f	file:
advance	scanner.c	/^static char advance() {$/;"	f	file:
allocateObject	object.c	/^static Obj* allocateObject(size_t size, ObjType type) {$/;"	f	file:
allocateString	object.c	/^static ObjString* allocateString(char* chars, int length,$/;"	f	file:
and_	compiler.c	/^static void and_(bool canAssign) {$/;"	f	file:
argumentList	compiler.c	/^static uint8_t argumentList() {$/;"	f	file:
arity	object.h	/^  int arity;$/;"	m	struct:__anon17
as	value.h	/^  } as; $/;"	m	struct:__anon5	typeref:union:__anon5::__anon6
beginScope	compiler.c	/^static void beginScope() {$/;"	f	file:
binary	compiler.c	/^static void binary(bool canAssign) {$/;"	f	file:
blackenObject	memory.c	/^static void blackenObject(Obj* object) {$/;"	f	file:
block	compiler.c	/^static void block() {$/;"	f	file:
boolean	value.h	/^    bool boolean;$/;"	m	union:__anon5::__anon6
byteInstruction	debug.c	/^static int byteInstruction(const char* name, Chunk* chunk,$/;"	f	file:
bytesAllocated	vm.h	/^  size_t bytesAllocated;$/;"	m	struct:__anon24
call	compiler.c	/^static void call(bool canAssign) {$/;"	f	file:
call	vm.c	/^static bool call(ObjClosure* closure, int argCount) {$/;"	f	file:
callValue	vm.c	/^static bool callValue(Value callee, int argCount) {$/;"	f	file:
capacity	chunk.h	/^  int capacity;$/;"	m	struct:__anon3
capacity	table.h	/^  int capacity;$/;"	m	struct:__anon22
capacity	value.h	/^  int capacity;$/;"	m	struct:__anon7
captureUpvalue	vm.c	/^static ObjUpvalue* captureUpvalue(Value* local) {$/;"	f	file:
chars	object.h	/^  char* chars;$/;"	m	struct:sObjString
check	compiler.c	/^static bool check(TokenType type) {$/;"	f	file:
checkKeyword	scanner.c	/^static TokenType checkKeyword(int start, int length,$/;"	f	file:
chunk	object.h	/^  Chunk chunk;$/;"	m	struct:__anon17
clockNative	vm.c	/^static Value clockNative(int argCount, Value* args) {$/;"	f	file:
closeUpvalues	vm.c	/^static void closeUpvalues(Value* last) {$/;"	f	file:
closed	object.h	/^  Value closed;$/;"	m	struct:ObjUpvalue
closure	vm.h	/^  ObjClosure* closure;$/;"	m	struct:__anon23
clox_chunk_h	chunk.h	/^#define clox_chunk_h$/;"	d
clox_common_h	common.h	/^#define clox_common_h$/;"	d
clox_compiler_h	compiler.h	/^#define clox_compiler_h$/;"	d
clox_debug_h	debug.h	/^#define clox_debug_h$/;"	d
clox_memory_h	memory.h	/^#define clox_memory_h$/;"	d
clox_object_h	object.h	/^#define clox_object_h$/;"	d
clox_scanner_h	scanner.h	/^#define clox_scanner_h$/;"	d
clox_table_h	table.h	/^#define clox_table_h$/;"	d
clox_value_h	value.h	/^#define clox_value_h$/;"	d
clox_vm_h	vm.h	/^#define clox_vm_h$/;"	d
code	chunk.h	/^  uint8_t* code;$/;"	m	struct:__anon3
collectGarbage	memory.c	/^void collectGarbage() {$/;"	f
compile	compiler.c	/^ObjFunction* compile(const char* source) {$/;"	f
concatenate	vm.c	/^static void concatenate() {$/;"	f	file:
constantInstruction	debug.c	/^static int constantInstruction(const char* name, Chunk* chunk,$/;"	f	file:
constants	chunk.h	/^  ValueArray constants;$/;"	m	struct:__anon3
consume	compiler.c	/^static void consume(TokenType type, const char* message) {$/;"	f	file:
copyString	object.c	/^ObjString* copyString(const char* chars, int length) {$/;"	f
count	chunk.h	/^  int count;$/;"	m	struct:__anon3
count	table.h	/^  int count;$/;"	m	struct:__anon22
count	value.h	/^  int count;$/;"	m	struct:__anon7
current	compiler.c	/^  Token current;$/;"	m	struct:__anon10	file:
current	compiler.c	/^Compiler* current = NULL;$/;"	v
current	scanner.c	/^  const char* current;$/;"	m	struct:__anon1	file:
currentChunk	compiler.c	/^static Chunk* currentChunk() {$/;"	f	file:
declaration	compiler.c	/^static void declaration() {$/;"	f	file:
declareVariable	compiler.c	/^static void declareVariable() {$/;"	f	file:
defineNative	vm.c	/^static void defineNative(const char* name, NativeFn function) {$/;"	f	file:
defineVariable	compiler.c	/^static void defineVariable(uint8_t global) {$/;"	f	file:
depth	compiler.c	/^  int depth;$/;"	m	struct:__anon13	file:
disassembleChunk	debug.c	/^void disassembleChunk(Chunk* chunk, const char* name) {$/;"	f
disassembleInstruction	debug.c	/^int disassembleInstruction(Chunk* chunk, int offset) {$/;"	f
emitByte	compiler.c	/^static void emitByte(uint8_t byte) {$/;"	f	file:
emitBytes	compiler.c	/^static void emitBytes(uint8_t byte1, uint8_t byte2) {$/;"	f	file:
emitConstant	compiler.c	/^static void emitConstant(Value value) {$/;"	f	file:
emitJump	compiler.c	/^static int emitJump(uint8_t instruction) {$/;"	f	file:
emitLoop	compiler.c	/^static void emitLoop(int loopStart) {$/;"	f	file:
emitReturn	compiler.c	/^static void emitReturn() {$/;"	f	file:
enclosing	compiler.c	/^  struct Compiler* enclosing;$/;"	m	struct:Compiler	typeref:struct:Compiler::Compiler	file:
endCompiler	compiler.c	/^static ObjFunction* endCompiler() {$/;"	f	file:
endScope	compiler.c	/^static void endScope() {$/;"	f	file:
entries	table.h	/^  Entry* entries;$/;"	m	struct:__anon22
error	compiler.c	/^static void error(const char* message) {$/;"	f	file:
errorAt	compiler.c	/^static void errorAt(Token* token, const char* message) {$/;"	f	file:
errorAtCurrent	compiler.c	/^static void errorAtCurrent(const char* message) {$/;"	f	file:
errorToken	scanner.c	/^static Token errorToken(const char* message) {$/;"	f	file:
expression	compiler.c	/^static void expression() {$/;"	f	file:
expressionStatement	compiler.c	/^static void expressionStatement() {$/;"	f	file:
findEntry	table.c	/^static Entry* findEntry(Entry* entries, int capacity,$/;"	f	file:
forStatement	compiler.c	/^static void forStatement() {$/;"	f	file:
frameCount	vm.h	/^  int frameCount;$/;"	m	struct:__anon24
frames	vm.h	/^  CallFrame frames[FRAMES_MAX];$/;"	m	struct:__anon24
freeChunk	chunk.c	/^void freeChunk(Chunk* chunk) {$/;"	f
freeObject	memory.c	/^static void freeObject(Obj* object) {$/;"	f	file:
freeObjects	memory.c	/^void freeObjects() {$/;"	f
freeTable	table.c	/^void freeTable(Table* table) {$/;"	f
freeVM	vm.c	/^void freeVM() {$/;"	f
freeValueArray	value.c	/^void freeValueArray(ValueArray* array) {$/;"	f
funDeclaration	compiler.c	/^static void funDeclaration() {$/;"	f	file:
function	compiler.c	/^  ObjFunction* function;$/;"	m	struct:Compiler	file:
function	compiler.c	/^static void function(FunctionType type) {$/;"	f	file:
function	object.h	/^  NativeFn function;$/;"	m	struct:__anon18
function	object.h	/^  ObjFunction* function;$/;"	m	struct:__anon19
getRule	compiler.c	/^static ParseRule* getRule(TokenType type) {$/;"	f	file:
globals	vm.h	/^  Table globals;$/;"	m	struct:__anon24
grayCapacity	vm.h	/^  int grayCapacity;$/;"	m	struct:__anon24
grayCount	vm.h	/^  int grayCount;$/;"	m	struct:__anon24
grayStack	vm.h	/^  Obj** grayStack;$/;"	m	struct:__anon24
grouping	compiler.c	/^static void grouping(bool canAssign) {$/;"	f	file:
hadError	compiler.c	/^  bool hadError;$/;"	m	struct:__anon10	file:
hash	object.h	/^  uint32_t hash;$/;"	m	struct:sObjString
hashString	object.c	/^static uint32_t hashString(const char* key, int length) {$/;"	f	file:
identifier	scanner.c	/^static Token identifier() {$/;"	f	file:
identifierConstant	compiler.c	/^static uint8_t identifierConstant(Token* name) {$/;"	f	file:
identifierType	scanner.c	/^static TokenType identifierType()$/;"	f	file:
identifiersEqual	compiler.c	/^static bool identifiersEqual(Token* a, Token* b) {$/;"	f	file:
ifStatement	compiler.c	/^static void ifStatement() {$/;"	f	file:
index	compiler.c	/^  uint8_t index;$/;"	m	struct:__anon14	file:
infix	compiler.c	/^  ParseFn infix;$/;"	m	struct:__anon12	file:
initChunk	chunk.c	/^void initChunk(Chunk* chunk) {$/;"	f
initCompiler	compiler.c	/^static void initCompiler(Compiler* compiler, FunctionType type) {$/;"	f	file:
initScanner	scanner.c	/^void initScanner(const char* source) {$/;"	f
initTable	table.c	/^void initTable(Table* table) {$/;"	f
initVM	vm.c	/^void initVM() {$/;"	f
initValueArray	value.c	/^void initValueArray(ValueArray* array) {$/;"	f
interpret	vm.c	/^InterpretResult interpret(const char* source) {$/;"	f
ip	vm.h	/^  uint8_t* ip;$/;"	m	struct:__anon23
isAlpha	scanner.c	/^static bool isAlpha(char c) {$/;"	f	file:
isAtEnd	scanner.c	/^static bool isAtEnd() {$/;"	f	file:
isCaptured	compiler.c	/^  bool isCaptured;$/;"	m	struct:__anon13	file:
isDigit	scanner.c	/^static bool isDigit(char c) {$/;"	f	file:
isFalsey	vm.c	/^static bool isFalsey(Value value) {$/;"	f	file:
isLocal	compiler.c	/^  bool isLocal;$/;"	m	struct:__anon14	file:
isMarked	object.h	/^  bool isMarked;$/;"	m	struct:sObj
isObjType	object.h	/^static inline bool isObjType(Value value, ObjType type) {$/;"	f
jumpInstruction	debug.c	/^static int jumpInstruction(const char* name, int sign,$/;"	f	file:
key	table.h	/^  ObjString* key;$/;"	m	struct:__anon21
length	object.h	/^  int length;$/;"	m	struct:sObjString
length	scanner.h	/^  int length;$/;"	m	struct:__anon9
line	scanner.c	/^  int line;$/;"	m	struct:__anon1	file:
line	scanner.h	/^  int line;$/;"	m	struct:__anon9
lines	chunk.h	/^  int* lines;$/;"	m	struct:__anon3
literal	compiler.c	/^static void literal(bool canAssign) {$/;"	f	file:
localCount	compiler.c	/^  int localCount;$/;"	m	struct:Compiler	file:
locals	compiler.c	/^  Local locals[UINT8_COUNT];$/;"	m	struct:Compiler	file:
location	object.h	/^  Value* location;$/;"	m	struct:ObjUpvalue
main	main.c	/^int main(int argc, const char* argv[]) {$/;"	f
makeConstant	compiler.c	/^static uint8_t makeConstant(Value value) {$/;"	f	file:
makeToken	scanner.c	/^static Token makeToken(TokenType type) {$/;"	f	file:
markArray	memory.c	/^static void markArray(ValueArray* array) {$/;"	f	file:
markCompilerRoots	compiler.c	/^void markCompilerRoots() {$/;"	f
markInitialized	compiler.c	/^static void markInitialized() {$/;"	f	file:
markObject	memory.c	/^void markObject(Obj* object) {$/;"	f
markRoots	memory.c	/^static void markRoots() {$/;"	f	file:
markTable	table.c	/^void markTable(Table* table) {$/;"	f
markValue	memory.c	/^void markValue(Value value) {$/;"	f
match	compiler.c	/^static bool match(TokenType type) {$/;"	f	file:
match	scanner.c	/^static bool match(char expected) {$/;"	f	file:
name	compiler.c	/^  Token name;$/;"	m	struct:__anon13	file:
name	object.h	/^  ObjString* name;$/;"	m	struct:__anon17
name	object.h	/^  ObjString* name;$/;"	m	struct:__anon20
namedVariable	compiler.c	/^static void namedVariable(Token name, bool canAssign) {$/;"	f	file:
newClass	object.c	/^ObjClass* newClass(ObjString* name) {$/;"	f
newClosure	object.c	/^ObjClosure* newClosure(ObjFunction* function) {$/;"	f
newFunction	object.c	/^ObjFunction* newFunction() {$/;"	f
newNative	object.c	/^ObjNative* newNative(NativeFn function) {$/;"	f
newUpvalue	object.c	/^ObjUpvalue* newUpvalue(Value* slot) {$/;"	f
next	object.h	/^  struct ObjUpvalue* next;$/;"	m	struct:ObjUpvalue	typeref:struct:ObjUpvalue::ObjUpvalue
next	object.h	/^  struct sObj* next;$/;"	m	struct:sObj	typeref:struct:sObj::sObj
nextGC	vm.h	/^  size_t nextGC;$/;"	m	struct:__anon24
number	compiler.c	/^static void number(bool canAssign) {$/;"	f	file:
number	scanner.c	/^static Token number() {$/;"	f	file:
number	value.h	/^    double number;$/;"	m	union:__anon5::__anon6
obj	object.h	/^  Obj obj;$/;"	m	struct:ObjUpvalue
obj	object.h	/^  Obj obj;$/;"	m	struct:__anon17
obj	object.h	/^  Obj obj;$/;"	m	struct:__anon18
obj	object.h	/^  Obj obj;$/;"	m	struct:__anon19
obj	object.h	/^  Obj obj;$/;"	m	struct:__anon20
obj	object.h	/^  Obj obj;$/;"	m	struct:sObjString
obj	value.h	/^    Obj* obj;$/;"	m	union:__anon5::__anon6
objects	vm.h	/^  Obj* objects;$/;"	m	struct:__anon24
openUpvalues	vm.h	/^  ObjUpvalue* openUpvalues;$/;"	m	struct:__anon24
or_	compiler.c	/^static void or_(bool canAssign) {$/;"	f	file:
panicMode	compiler.c	/^  bool panicMode;$/;"	m	struct:__anon10	file:
parsePrecedence	compiler.c	/^static void parsePrecedence(Precedence precedence) {$/;"	f	file:
parseVariable	compiler.c	/^static uint8_t parseVariable(const char* errorMessage) {$/;"	f	file:
parser	compiler.c	/^Parser parser;$/;"	v
patchJump	compiler.c	/^static void patchJump(int offset) {$/;"	f	file:
peek	scanner.c	/^static char peek() {$/;"	f	file:
peek	vm.c	/^static Value peek(int distance) {$/;"	f	file:
peekNext	scanner.c	/^static char peekNext() {$/;"	f	file:
pop	vm.c	/^Value pop() {$/;"	f
precedence	compiler.c	/^  Precedence precedence;$/;"	m	struct:__anon12	file:
prefix	compiler.c	/^  ParseFn prefix;$/;"	m	struct:__anon12	file:
previous	compiler.c	/^  Token previous;$/;"	m	struct:__anon10	file:
printFunction	object.c	/^static void printFunction(ObjFunction* function) {$/;"	f	file:
printObject	object.c	/^void printObject(Value value) {$/;"	f
printStatement	compiler.c	/^static void printStatement() {$/;"	f	file:
printValue	value.c	/^void printValue(Value value) {$/;"	f
push	vm.c	/^void push(Value value) {$/;"	f
readFile	main.c	/^static char* readFile(const char* path) {$/;"	f	file:
reallocate	memory.c	/^void* reallocate(void* pointer, size_t oldSize, size_t newSize) {$/;"	f
repl	main.c	/^static void repl() {$/;"	f	file:
resetStack	vm.c	/^static void resetStack() {$/;"	f	file:
resolveLocal	compiler.c	/^static int resolveLocal(Compiler* compiler, Token* name) {$/;"	f	file:
resolveUpvalue	compiler.c	/^static int resolveUpvalue(Compiler* compiler, Token* name) {$/;"	f	file:
returnStatement	compiler.c	/^static void returnStatement() {$/;"	f	file:
rules	compiler.c	/^ParseRule rules[] = {$/;"	v
rules	compiler.c	/^ParseRule rules[];$/;"	v
run	vm.c	/^static InterpretResult run() {$/;"	f	file:
runFile	main.c	/^static void runFile(const char* path) {$/;"	f	file:
runtimeError	vm.c	/^static void runtimeError(const char* format, ...) {$/;"	f	file:
sObj	object.h	/^struct sObj {$/;"	s
sObjString	object.h	/^struct sObjString {$/;"	s
scanToken	scanner.c	/^Token scanToken() {$/;"	f
scanner	scanner.c	/^Scanner scanner;$/;"	v
scopeDepth	compiler.c	/^  int scopeDepth;$/;"	m	struct:Compiler	file:
simpleInstruction	debug.c	/^static int simpleInstruction(const char* name, int offset) {$/;"	f	file:
skipWhitespace	scanner.c	/^static void skipWhitespace() {$/;"	f	file:
slots	vm.h	/^  Value* slots;$/;"	m	struct:__anon23
stack	vm.h	/^  Value stack[STACK_MAX];$/;"	m	struct:__anon24
stackTop	vm.h	/^  Value* stackTop;$/;"	m	struct:__anon24
start	scanner.c	/^  const char* start;$/;"	m	struct:__anon1	file:
start	scanner.h	/^  const char* start;$/;"	m	struct:__anon9
statement	compiler.c	/^static void statement() {$/;"	f	file:
string	compiler.c	/^static void string(bool canAssign) {$/;"	f	file:
string	scanner.c	/^static Token string() {$/;"	f	file:
strings	vm.h	/^  Table strings;$/;"	m	struct:__anon24
sweep	memory.c	/^static void sweep() {$/;"	f	file:
synchronize	compiler.c	/^static void synchronize() {$/;"	f	file:
tableAddAll	table.c	/^void tableAddAll(Table* from, Table* to) {$/;"	f
tableDelete	table.c	/^bool tableDelete(Table* table, ObjString* key) {$/;"	f
tableFindString	table.c	/^ObjString* tableFindString(Table* table, const char* chars,$/;"	f
tableGet	table.c	/^bool tableGet(Table* table, ObjString* key, Value* value) {$/;"	f
tableRemoveWhite	table.c	/^void tableRemoveWhite(Table* table) {$/;"	f
tableSet	table.c	/^bool tableSet(Table* table, ObjString* key, Value value) {$/;"	f
takeString	object.c	/^ObjString* takeString(char* chars, int length) {$/;"	f
traceReferences	memory.c	/^static void traceReferences() {$/;"	f	file:
type	compiler.c	/^  FunctionType type;$/;"	m	struct:Compiler	file:
type	object.h	/^  ObjType type;$/;"	m	struct:sObj
type	scanner.h	/^  TokenType type;$/;"	m	struct:__anon9
type	value.h	/^  ValueType type;$/;"	m	struct:__anon5
unary	compiler.c	/^static void unary(bool canAssign) {$/;"	f	file:
upvalueCount	object.h	/^  int upvalueCount;$/;"	m	struct:__anon17
upvalueCount	object.h	/^  int upvalueCount;$/;"	m	struct:__anon19
upvalues	compiler.c	/^  Upvalue upvalues[UINT8_COUNT];$/;"	m	struct:Compiler	file:
upvalues	object.h	/^  ObjUpvalue** upvalues;$/;"	m	struct:__anon19
value	table.h	/^  Value value;$/;"	m	struct:__anon21
values	value.h	/^  Value* values;$/;"	m	struct:__anon7
valuesEqual	value.c	/^bool valuesEqual(Value a, Value b) {$/;"	f
varDeclaration	compiler.c	/^static void varDeclaration() {$/;"	f	file:
variable	compiler.c	/^static void variable(bool canAssign) {$/;"	f	file:
vm	vm.c	/^VM vm; $/;"	v
whileStatement	compiler.c	/^static void whileStatement() {$/;"	f	file:
writeChunk	chunk.c	/^void writeChunk(Chunk* chunk, uint8_t byte, int line) {$/;"	f
writeValueArray	value.c	/^void writeValueArray(ValueArray* array, Value value) {$/;"	f
